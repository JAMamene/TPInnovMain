-----------------------------------------------------------------------------------------	
André Guillaume															Zaki Berouk
Puskaric Jean-Adam														Matthieu Maxit
		
								Description du protocole
				
Nous avons utilisé la sérialisation objet. On dispose donc des objets sérialisables
suivants: Answer, Idea, Participation, Request.

Chaque requête est contenue dans un objet Request, contenant le nom de la méthode
à invoquer et les paramètres éventuels nécéssaires. Request dispose de plusieurs
constructeurs, chacun correspondant à l'une des 4 requêtes.

Le serveur doit posséder un objet distant implémentant RemoteListInterface. Il doit 
invoquer la méthode contenue dans la requête sur cet objet et renvoyer au client l'objet
Answer obtenu. Answer contient les éventuels objets de la réponse à recaster par le 
client selon la requête effectuée et un code de statut correspondant au succès de la 
requête.

								  Requêtes disponibles
								
Lister toutes les idées :
	- Requête: constructeur Request()
	- Answer: les objets contenus sont des instances de la clase Idea

Créer une nouvelle idée:
	- Requête: constructeur Request(Idea idea), où idea est l'idée à ajouter
	- Answer: aucun objet n'est contenu dans la réponse
	
Participer à une idée:
	- Requête: constructeur Request(Participation participation), la participation
	contenant le mail de la personne intéréssée et l'id de l'idée concernée
	- Answer: aucun objet n'est contenu dans la réponse
	
Voir les personnes intéréssées pour une idée:
	- Requête: constructeur Request(Integer id), où id est l'id de l'idée concernée
	- Answer: les objets contenus sont des String contenant les mails des personnes 
	intéréssées


                                Notes d'implémentation

A la base nous avons voulu faire transiter directement les objets méthodes par la socket
afin de permettre une réflexion plus propre, toutefois les objets méthodes n'étant pas
sérialisable car dépendant de la JVM, nous avons choisi de simplement faire passer le nom
de la méthode. Cela a l'avantage de ne pas forcer un groupe suivant notre protocole à
utiliser la réflexion java mais de nous permettre de l'utiliser pour éviter des switchs ou autre.

Le fait d'utiliser le client et le serveur sur la même machine entrainait des conflits entre les
références des objets ce qui nous a contraint de définir des constructeurs par recopie dans Idea
pour ne pas créer d'inconsistance lors de l'échange de données.

Il aurait été intéréssant d'améliorer la gestion d'erreur de notre protocole mais il est compliqué
de le changer maintenant alors qu'un autre binôme l'utilise.